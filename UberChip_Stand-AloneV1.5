//************************************************* Stand-Alone version v1.5 for internal install / no debug ******************************************************//
// \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/ //
//                                                                                                                                                                 //
//  A STUPID DUMBED DOWN VERSION OF A PSX MODCHIP BY A TOTAL AMATEUR WITH A FEW DAYS OF ARDUINO TINKERING EXPERIENCE                                               //
//                                        I dub Thee: Teh UbeR ChiP  V1.00                                                                                         //
//                                            VAJSKIDS JULY 2021                                                                                                   //
//  SOURCES OF INFORMATION:                                                                                                                                        //
//                          https://github.com/vxbinaca/modavr/blob/master/modavr.asm                                                                              //
//                          http://www.oldcrows.net/mcc1.html                                                                                                      //
//                          https://github.com/Gadorach/PSX-MultiMode3-PIC12F683/blob/master/MPLAB%20X/MM3-12F683.X/main.c                                         //
//                          And an older version of PSNEE source code before it also covered OneChip/ psone , the latest one has IMO being over optimised          //
//                          and is harder to understand.                                                                                                           //
//tools used:                                                                                                                                                      //
//$17 ebay logic analyser (watched data line on an old crow + data lines on my arduino + data line on console with genuine disc - 11 injections)                   //
//Logic 2 (software)                                                                                                                                               //
//PU18 SCPH5502 with a drive from another playstation and an extension ribbon cable                                                                                //
// Arduino Nano (clone with old bootloader)                                                                                                                        //
// An old modchip pulled out of one of many systems I've flipped                                                                                                   //
//                                                                                                                                                                 //
// Most of the time was spent trying to understand "what to inject" as outlined below.... otherwise this would have being working within a couple of hours         //
// This is a great example for a learner / by a learner                                                                                                            //
// This is currently set up to watch on the serial monitor with a ~3.5v "power sensor" wire as oppose being hardwired into the console                             //
// which would be a very easy change.                                                                                                                              //
//                                                                                                                                                                 //                                                                                                                                                           //
//  https://imgur.com/eLf89y5                                                                                                                                      //
// IT BOOTS UM JAMMER LAMMY [NTSC], the only game I know that can detect a modchip!!                                                                               //
//                                                                                                                                                                 //
//V1.5: Some minor timing and magic key injection tweaks, added multidisc support. Extra lid sensor wire in defines.                                               //
// Audio CD Fix + Jumps straight into CD player if an audio disc is inserted, this was just a delay at boot before injections as an audio                          //
// CD is detected within the first 4 or 5 seconds and launches the player. Injecting the String / 'magic key' after this time                                      //
// doesn't affect boot time of a game disc what so ever. Releasing Gate/ Data pins breaks the program, possibly because of the register states used but            //
// releasing them isn't required - just can't keep pumping the 'magic key' down the DATA line or it's picked up by anti-stealth.                                   //
// ...Will likely move onto a PSOne version after this. Proper Install diagrams will be coming!                                                                    //
// You won't be able to break this using the console normally, but if you really, really try you could probably flag an anti-mod                                   //
//                                                                                                                                                                 //
//                                                                                                                                                                 //
// \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/         \m/      \m/ //


//Define the used pins
#define DRIVE_LID_SENS 8
#define GATE 2
#define DATA 12
#define P_SENS 4
#define mchipregister PIND  //register for monitoring high/low states (read only)
#define mchipregwrite PORTD //register to write pin states to in setup
#define DRIVE_LID_SENS_REG PINB //the register with the DATA line and our drive lid sensor line
int bitdelay (3974); //delay between bits sent to drive controller (MS)
int stringdelay (67); //delay between string injections
const int System_Off = (0B00000011); //RX & TX are always high
const int System_On = (0B00001011); //
const int Lid_Open = (0B000001); //so we don't have to refer to the states in bits further on
const int Lid_Closed = (0B000000);
int injectcounter = 0; //variable for injection loop storage

void setup() {
  Serial.begin(57600); //serial monitor for debugging
  //Set up the used pins
  pinMode (GATE, OUTPUT);
  pinMode (DATA, OUTPUT);
  pinMode (P_SENS, INPUT);
  pinMode (DRIVE_LID_SENS, INPUT);
  //setup default register state (psx off)
  digitalWrite (mchipregwrite, 0B00001011);
  //otherwise LED pin 13 will go high when flashing and break code
  //and sets true states of other unused pins in this register
  digitalWrite (DRIVE_LID_SENS_REG, 0B000000);
}
void NewDisc() {
  do
  {
    delay (1500);
  }
  while (DRIVE_LID_SENS_REG == Lid_Open);
  inject();
}
void DriveLidStatus() {
  if (DRIVE_LID_SENS_REG == Lid_Closed) { //state of this register after initial injection routine with lid closed
    injectcounter = 0;                  //This reset is in case of multidisc/ multiple injection routines
  }
  else if (DRIVE_LID_SENS_REG == Lid_Open) {  //monitor register state with this pin for sensing purposes, data idles low after injection, only need to look for a change in one bit (lid sens pin)
    delay (500);
    NewDisc();
  }
  DriveLidStatus();                           //forms a conditional if loop
}
void PowerUpDelay() {
  inject(); //ready to inject
}
void inject() {
  if (injectcounter == 100)    //The amount of times you want to inject the string
  {
    DriveLidStatus();          // call drive lid status routine
  }
  else
  {
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay); //delay between single bit injections
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 1);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delayMicroseconds (bitdelay);
    digitalWrite (DATA, 0);
    delay (stringdelay); //delay between string injects
    injectcounter = (injectcounter + 1);
    Serial.println ("   SCEE String Injected     "); //delays between injects as well as serial monitor stuff
    inject();
  }
}
void loop() {
  if (DRIVE_LID_SENS_REG == Lid_Closed || mchipregister == System_On) //if power off or lid closed
  {
    delay (5200);
    PowerUpDelay();
  }
  else
  {
    return;
  }
}
