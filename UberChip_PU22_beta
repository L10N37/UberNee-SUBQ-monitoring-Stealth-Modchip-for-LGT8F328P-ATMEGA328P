//UberChip for PU22, debug interim release for anyone interested in the differences 
// VajSkids 2021
// Only confirmed working with Galerians which took forever to boot but ran flawlessly - tried SFA III Alpha and funny noises at black screen then the drive gives up
//To be continued ....


//Define the used pins
#define DRIVE_LID_SENS 8
#define GATE 2
#define DATA 12
#define P_SENS 4
#define mchipregister PIND  //register for monitoring high/low states (read only)
#define mchipregwrite PORTD //register to write pin states to in setup
#define DRIVE_LID_SENS_REG PINB //the register with the DATA line and our drive lid sensor line
int bitdelay (4200); //delay between bits sent to drive controller (MS)
int stringdelay (120); //delay between string injections
const int System_Off = (0B00000011); //RX & TX are always high
const int System_On = (0B00001011); //
const int Lid_Open = (0B000001); //so we don't have to refer to the states in bits further on
const int Lid_Closed = (0B000000);
char Dots[1] = ".";
char equalsign[] = "==============================";
int injectcounter = 0; //variable for injection loop storage
char notice[] = "Playstation Console isn't Powered-On or the powers on and the Drive Lid is Open";
char blank[] = " "; //just to fix an annoying debugging bug
unsigned int DiscSwap = 0;
/*  00110101  00111101 01011101  01011101 (remove start bit "1" and two stop bits "0, 0" between each byte)

    10111010 10111010 10111100 10101100   (Reverse it)

    01000101 01000101 01000011 01010011   (Invert it, correct here sending LSB first/ Little Endian)

    01010011 01000011 01000101 01000101   (Big Endian, MSB first, we have "SCEE")                       */


/*PORTD maps to Arduino digital pins 0 to 7

    DDRD - The Port D Data Direction Register - read/write
    PORTD - The Port D Data Register - read/write
    PIND - The Port D Input Pins Register - read only


    PORTB maps to Arduino digital pins 8 to 13 The two high bits (6 & 7) map to the crystal pins and are not usable

    DDRB - The Port B Data Direction Register - read/write
    PORTB - The Port B Data Register - read/write
    PINB - The Port B Input Pins Register - read only           */


void setup() {

  Serial.begin(57600); //serial monitor for debugging
  //Set up the used pins
  pinMode (GATE, OUTPUT);
  pinMode (DATA, OUTPUT);
  digitalWrite (DATA, LOW);
  pinMode (P_SENS, INPUT);
  pinMode (DRIVE_LID_SENS, INPUT);
  //setup default register state (psx off)
  digitalWrite (mchipregwrite, 0B00001011);
  //otherwise LED pin 13 will go high when flashing and break code
  //and sets true states of other unused pins in this register
  digitalWrite (DRIVE_LID_SENS_REG, 0B000000);
}
void NewDisc() {
  do
  {
    delay (1500);
    Serial.println ("   ...Awaiting disc swap and drive lid closure  " );
  }
  while (DRIVE_LID_SENS_REG == Lid_Open);
  inject();
}
void DriveLidStatus() { //a conditional loop for the status of the drive lid sensor pin using the state of it's entire register
  //for multi-disc games

  pinMode (DATA, INPUT); //make sure data isn't impeding the line after injection cycle

  if (DRIVE_LID_SENS_REG == Lid_Closed) { //state of this register after initial injection routine with lid closed

    injectcounter = 0;                  //This reset is in case of multidisc/ multiple injection routines
    Serial.println (" Injection cycles complete ");
    Serial.println (" ...Gate will remain closed "); //print more debug stuff
    Serial.println (equalsign);
    delay (850);
    Serial.println ("   Stealth chip enabled, monitoring disc drive lid status   ");
  }
  else if (DRIVE_LID_SENS_REG == Lid_Open) {  //monitor register state with this pin for sensing purposes, data idles low after injection, only need to look for a change in one bit (lid sens pin)
    Serial.println (" Drive Lid is Open!" );  //print this to serial monitor while drive lid is open and wait for it to close again
    delay (850);
    DiscSwap = (DiscSwap + 1);                   // **debug purposes**
    Serial.println ("Disc swapped ");            // **              **
    Serial.print (DiscSwap);
    Serial.print (  "   time/s!"  );
    delay (500);
    NewDisc();

  }
  DriveLidStatus();                           //forms a conditional if loop
}

void PowerUpDelay() { //A power up delay with serial monitor stuff, self explanatory
  Serial.println ("  PSX Console Powered-On & Drive lid is closed ...Data Gate Closed, Preparing to Inject!   ");
  delay (500);
  Serial.println (Dots);
  delay (500);
  Serial.println (Dots);
  delay (500);
  Serial.println (Dots);
  delay (500);
  Serial.println (Dots);
  delay (250);
  Serial.println (Dots);
  delay (250);
  Serial.println (Dots);
  delay (250);
  Serial.println (Dots);
  delay (250);
  Serial.println (Dots);
  delay (150);
  Serial.println (Dots);
  delay (150);
  Serial.println ("  STARTING INJECTION CYCLES   ");
  Serial.println (equalsign);
  delay (2200);                                         //Audio-CD Fix boot delay, detects audio disc within this time frame
  // but squirting the region string in after this point is ok for a game disc
  // doesn't affect game boot time
  inject(); //ready to inject
}

void inject() {

  if (injectcounter == 85)
  )    //The amount of times you want to inject the string
                              //This is long enough to load games that take a while to start (i.e Dino Crisis, RE3) but stops
                               //string injection (goes stealth) soon enough for anti-mod game (i.e Umjammer Lammy) to not flag the chip
                               //likely safe to increase to another 10 to 30 injections??
  {   
    DriveLidStatus();          // call drive lid status routine
  }
  else 
  {
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay); //delay between single bit injections
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, INPUT);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delayMicroseconds (bitdelay);
    pinMode (DATA, OUTPUT);digitalWrite (DATA, LOW);
    delay (stringdelay); //delay between string injects
    injectcounter = (injectcounter + 1);
    //stringdelay = (stringdelay +5);
    Serial.println ("   SCEE String Injected     "); //delays between injects as well as serial monitor stuff
    inject();
  }
}

void loop() {

  delay(1800);
  if (DRIVE_LID_SENS_REG == Lid_Open || mchipregister == System_Off) //if power off or lid closed
  {
    Serial.println (notice);  //keep printing this to serial monitor
    Serial.print (blank);     //otherwise it prints a dot along with 'notice' 9 times after jumping to powerupdelay, instead of just the 9 new line dots (?!?!)
  }
  else
  {
    PowerUpDelay();             // else jump to here
  }
}
